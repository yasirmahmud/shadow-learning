<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Course Video</title>
  <link rel="stylesheet" href="./assets/style.css"/>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js">marked.setOptions({ mangle: false, headerIds: false });</script>

<header class="site-header">
  <div class="container">
    <div class="brand">
      <!-- replaced UF block with logo -->
      <img src="./images/logo.png" alt="Site Logo" class="site-logo"/>
      <h1 id="course-title">Course Video</h1>
    </div>
    <nav class="site-nav"><a href="./index.html" class="nav-link">Home</a></nav>
  </div>
</header>

<main class="container">
  <div id="meta" class="panel"><p id="desc" class="video-meta"></p></div>

  <div id="wrap" class="yt-wrap yt-16x9">
    <div id="player"></div>
    <div id="overlay" class="overlay" aria-hidden="true"></div>
  </div>

  <section id="chat" class="chat" hidden>
    <div class="chat-header">
      <strong>Discussion</strong>
      <button id="exit-chat" class="btn btn-ghost btn-sm" type="button">Exit Chat</button>
    </div>
    <div id="thread"></div>
    <form id="compose" class="compose">
      <input id="msg" class="input" type="text" placeholder="Type your question and press Enter" autocomplete="off"/>
      <button class="btn btn-orange" type="submit">Send</button>
    </form>
  </section>
</main>

<script type="module">
import { qs, el, saveViaVercel, askLaptop } from './assets/ui.js';

// You can switch between localhost and ngrok by commenting/uncommenting:
const BACKEND_URL = 'https://saunciest-unethereal-clora.ngrok-free.dev';

// Keep supporting an optional course id for your chat/save payloads
const params = new URLSearchParams(location.search);
const courseId = params.get('id') || 'default';

// --- fetch video info from backend ---
let videoInfo;
try {
  const resp = await fetch(`${BACKEND_URL}/api/video-info`, {
    cache: 'no-store',
    headers: { 'ngrok-skip-browser-warning': 'true' } // <â€” important fix
  });
  const json = await resp.json();
  if (!json.ok) throw new Error(json.error || 'Failed to load video info');
  videoInfo = json.video_info || {};
} catch (err) {
  console.error(err);
  document.getElementById('wrap').innerHTML =
    '<div style="color:#fff;padding:24px">Could not load video info from backend.</div>';
  throw err;
}

// --- fill page title/desc using video info ---
const title = videoInfo.youtube_title || 'Course Video';
document.getElementById('course-title').textContent = title;
document.getElementById('desc').textContent = ''; // no description from backend for now

// --- parse YouTube URL to id + start ---
function parseYouTube(u) {
  try {
    const url = new URL(u);
    let id = '', start = 0;
    if (url.hostname.includes('youtu.be')) {
      id = url.pathname.replace(/^\//, '');
      const t = url.searchParams.get('t'); if (t) start = parseInt(t, 10) || 0;
    } else if (url.hostname.includes('youtube.com')) {
      id = url.searchParams.get('v') || '';
      const t = url.searchParams.get('t'); if (t) start = parseInt(t, 10) || 0;
    }
    return { id, start };
  } catch {
    return { id: '', start: 0 };
  }
}

const youtubeUrl = videoInfo.youtube_video_url;
if (!youtubeUrl) {
  document.getElementById('wrap').innerHTML =
    '<div style="color:#fff;padding:24px">No YouTube URL available from backend.</div>';
  throw new Error('Missing YouTube URL');
}

const { id: videoId, start } = parseYouTube(youtubeUrl);
if (!videoId) {
  document.getElementById('wrap').innerHTML =
    '<div style="color:#fff;padding:24px">Invalid YouTube URL from backend.</div>';
  throw new Error('Invalid YouTube URL');
}

// --- YouTube IFrame API bootstrap ---
await new Promise((resolve) => {
  const tag = document.createElement('script');
  tag.src = 'https://www.youtube.com/iframe_api';
  window.onYouTubeIframeAPIReady = () => resolve();
  document.head.appendChild(tag);
});

const overlay = document.getElementById('overlay');
const chat = document.getElementById('chat');
const thread = document.getElementById('thread');
const msgInput = document.getElementById('msg');
const compose = document.getElementById('compose');
const exitBtn = document.getElementById('exit-chat');

let player;
let lastTime = start || 0;
let chatStarted = false;

// Create the player
player = new window.YT.Player('player', {
  videoId: videoId,
  playerVars: {
    start: start || 0,
    rel: 0,
    modestbranding: 1,
    controls: 1,
    iv_load_policy: 3
  },
  events: {
    onReady: (e) => {
      window.player = player;
      window.dispatchEvent(new Event('primary-player-ready'));
      if (start) try { e.target.seekTo(start, true); } catch {}
    },
    onStateChange: (e) => {
      if (e.data === window.YT.PlayerState.PAUSED) {
        try { lastTime = Math.floor(player.getCurrentTime() || 0); } catch {}
        overlay.classList.add('show');
        chat.hidden = false;
        if (!chatStarted) { addMsg('ai', 'Do you have any questions about what you just watched?'); chatStarted = true; }
        msgInput.focus();
      } else if (e.data === window.YT.PlayerState.PLAYING) {
        overlay.classList.remove('show');
      }
    }
  }
});

// Space to pause + open chat (when not typing)
document.addEventListener('keydown', (e) => {
  const tag = (e.target.tagName || '').toLowerCase();
  const typing = e.target.isContentEditable || ['input','textarea','select','button'].includes(tag);
  if ((e.key === ' ' || e.code === 'Space' || e.key === 'Spacebar') && !typing) {
    e.preventDefault();
    try { player.pauseVideo(); } catch {}
  }
});

// --- chat helpers ---
function addMsg(role, text) {
  const row = document.createElement('div');
  row.className = 'msg ' + role;

  const bubble = document.createElement('div');
  bubble.className = 'bubble';

  try {
    bubble.innerHTML = marked.parse(text || '');
  } catch (err) {
    console.error('Markdown parse error:', err);
    bubble.textContent = text || '';
  }

  row.appendChild(bubble);
  thread.appendChild(row);
  thread.scrollTop = thread.scrollHeight;
}

function collectTranscript() {
  return [...document.querySelectorAll('.msg')].map(m => ({
    role: m.classList.contains('ai') ? 'assistant' : 'user',
    content: m.textContent.trim()
  }));
}

// Submit to backend + save to GitHub
compose.addEventListener('submit', async (ev) => {
  ev.preventDefault();
  const text = msgInput.value.trim();
  if (!text) return;
  addMsg('user', text);
  msgInput.value = '';

  try {
    await saveViaVercel({
      course: courseId,
      savedAt: new Date().toISOString(),
      video_chat: { atSeconds: lastTime, videoId, messages: collectTranscript() }
    });
  } catch (e) { console.error(e); }

  try {
    const response = await askLaptop({
      courseId,
      atSeconds: lastTime,
      messages: collectTranscript().map(m => ({
        role: m.role === 'assistant' ? 'assistant' : 'user',
        content: m.content
      }))
    });
    addMsg('ai', response.reply || 'No response.');
  } catch (err) {
    console.error(err);
    addMsg('ai', 'The assistant is unavailable right now. Please try again in a moment.');
  }
});

// Exit chat
exitBtn.addEventListener('click', () => {
  chat.hidden = true;
  overlay.classList.remove('show');
  try { player.playVideo(); } catch {}
});
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && !chat.hidden) {
    chat.hidden = true;
    overlay.classList.remove('show');
    try { player.playVideo(); } catch {}
  }
});
</script>

<script type="module" src="./assets/relevant-swap.js"></script>
<script type="module" src="./assets/relevant-swap.debug.js"></script>
</body>
</html>
