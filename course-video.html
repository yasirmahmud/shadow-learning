<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Course Video - GatorMate</title>
  <link rel="stylesheet" href="./assets/style.css"/>
  <style>
    /* ===== HEADER (UF Blue) ===== */
    .site-header {
      background-color: #0021A5; /* UF Blue */
      color: #fff;
      padding: 2rem 0;
    }
    .brand {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      flex-wrap: wrap;
    }
    .site-logo {
      width: 90px;
      height: auto;
      flex-shrink: 0;
      border-radius: 0.5rem;
      background: #fff;
      padding: 0.5rem;
    }
    .site-titles {
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* titles on the right of logo, left-aligned text */
      text-align: left;
    }
    .main-title {
      font-size: 2.5rem;
      font-weight: 800;
      margin: 0;
      background: linear-gradient(90deg, #ffffff, #f9a825); /* white â†’ UF orange accent */
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .subtitle {
      font-size: 1.2rem;
      font-weight: 500;
      font-style: italic;
      color: #ffffff;
      margin: 0.3rem 0 0.8rem;
      letter-spacing: 0.5px;
    }
    .subheading {
      font-size: 1.2rem;
      font-weight: 600;
      color: #ffffff; /* page-specific title in white at the bottom */
      margin: 0;
    }
    .site-nav {
      text-align: center;
      margin-top: 1rem;
    }
    .nav-link {
      color: #fff;
      text-decoration: none;
      font-weight: 600;
      margin: 0 1rem;
    }
    .nav-link:hover { text-decoration: underline; }
  </style>
</head>
<body>
<!-- Load marked, then configure it (split into two tags so options actually apply) -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
  if (window.marked) marked.setOptions({ mangle: false, headerIds: false });
</script>

<header class="site-header">
  <div class="container">
    <div class="brand">
      <!-- replaced UF block with logo -->
      <img src="./images/logo.png" alt="Site Logo" class="site-logo"/>
      <div class="site-titles">
        <h1 class="main-title">GatorMate</h1>
        <p class="subtitle">Revolutionizing Education</p>
        <h2 class="subheading" id="course-title">Course Video</h2>
      </div>
    </div>
    <nav class="site-nav"><a href="./index.html" class="nav-link">Home</a></nav>
  </div>
</header>

<main class="container">
  <div id="wrap" class="yt-wrap yt-16x9">
    <div id="player"></div>
    <div id="overlay" class="overlay" aria-hidden="true"></div>
  </div>

  <section id="chat" class="chat" hidden>
    <div class="chat-header">
      <strong>Discussion</strong>
      <button id="exit-chat" class="btn btn-ghost btn-sm" type="button">Exit Chat</button>
    </div>
    <div id="thread"></div>
    <form id="compose" class="compose">
      <input id="msg" class="input" type="text" placeholder="Type your question and press Enter" autocomplete="off"/>
      <button class="btn btn-orange" type="submit">Send</button>
    </form>
  </section>
</main>

<script type="module">
import { qs, el, saveViaVercel, askLaptop } from './assets/ui.js';

// You can switch between localhost and ngrok by commenting/uncommenting:
const BACKEND_URL = 'https://saunciest-unethereal-clora.ngrok-free.dev';

// Keep supporting an optional course id for your chat/save payloads
const params = new URLSearchParams(location.search);
const courseId = params.get('id') || 'default';

// --- fetch video info from backend ---
let videoInfo;
try {
  const resp = await fetch(`${BACKEND_URL}/api/video-info`, {
    cache: 'no-store',
    headers: { 'ngrok-skip-browser-warning': 'true' }
  });
  const json = await resp.json();
  if (!json.ok) throw new Error(json.error || 'Failed to load video info');
  videoInfo = json.video_info || {};
} catch (err) {
  console.error(err);
  document.getElementById('wrap').innerHTML =
    '<div style="color:#fff;padding:24px">Could not load video info from backend.</div>';
  throw err;
}

// --- fill page title using video info ---
const dynamicTitle = videoInfo.youtube_title || 'Course Video';
document.getElementById('course-title').textContent = dynamicTitle;

// --- parse YouTube URL to id + start ---
function parseYouTube(u) {
  try {
    const url = new URL(u);
    let id = '', start = 0;
    if (url.hostname.includes('youtu.be')) {
      id = url.pathname.replace(/^\//, '');
      const t = url.searchParams.get('t'); if (t) start = parseInt(t, 10) || 0;
    } else if (url.hostname.includes('youtube.com')) {
      id = url.searchParams.get('v') || '';
      const t = url.searchParams.get('t'); if (t) start = parseInt(t, 10) || 0;
    }
    return { id, start };
  } catch {
    return { id: '', start: 0 };
  }
}

const youtubeUrl = videoInfo.youtube_video_url;
if (!youtubeUrl) {
  document.getElementById('wrap').innerHTML =
    '<div style="color:#fff;padding:24px">No YouTube URL available from backend.</div>';
  throw new Error('Missing YouTube URL');
}

const { id: videoId, start } = parseYouTube(youtubeUrl);
if (!videoId) {
  document.getElementById('wrap').innerHTML =
    '<div style="color:#fff;padding:24px">Invalid YouTube URL from backend.</div>';
  throw new Error('Invalid YouTube URL');
}

// --- YouTube IFrame API bootstrap ---
await new Promise((resolve) => {
  const tag = document.createElement('script');
  tag.src = 'https://www.youtube.com/iframe_api';
  window.onYouTubeIframeAPIReady = () => resolve();
  document.head.appendChild(tag);
});

const overlay = document.getElementById('overlay');
const chat = document.getElementById('chat');
const thread = document.getElementById('thread');
const msgInput = document.getElementById('msg');
const compose = document.getElementById('compose');
const exitBtn = document.getElementById('exit-chat');

let player;
let lastTime = start || 0;
let chatStarted = false;

// Create the player
player = new window.YT.Player('player', {
  videoId: videoId,
  playerVars: {
    start: start || 0,
    rel: 0,
    modestbranding: 1,
    controls: 1,
    iv_load_policy: 3
  },
  events: {
    onReady: (e) => {
      window.player = player;
      window.dispatchEvent(new Event('primary-player-ready'));
      if (start) try { e.target.seekTo(start, true); } catch {}
    },
    onStateChange: (e) => {
      if (e.data === window.YT.PlayerState.PAUSED) {
        try { lastTime = Math.floor(player.getCurrentTime() || 0); } catch {}
        overlay.classList.add('show');
        chat.hidden = false;
        if (!chatStarted) { addMsg('ai', 'Do you have any questions about what you just watched?'); chatStarted = true; }
        msgInput.focus();
      } else if (e.data === window.YT.PlayerState.PLAYING) {
        overlay.classList.remove('show');
      }
    }
  }
});

// Space to pause + open chat (when not typing)
document.addEventListener('keydown', (e) => {
  const tag = (e.target.tagName || '').toLowerCase();
  const typing = e.target.isContentEditable || ['input','textarea','select','button'].includes(tag);
  if ((e.key === ' ' || e.code === 'Space' || e.key === 'Spacebar') && !typing) {
    e.preventDefault();
    try { player.pauseVideo(); } catch {}
  }
});

// --- chat helpers ---
function addMsg(role, text) {
  const row = document.createElement('div');
  row.className = 'msg ' + role;

  const bubble = document.createElement('div');
  bubble.className = 'bubble';

  try {
    bubble.innerHTML = marked.parse(text || '');
  } catch (err) {
    console.error('Markdown parse error:', err);
    bubble.textContent = text || '';
  }

  row.appendChild(bubble);
  thread.appendChild(row);
  thread.scrollTop = thread.scrollHeight;
}

function collectTranscript() {
  return [...document.querySelectorAll('.msg')].map(m => ({
    role: m.classList.contains('ai') ? 'assistant' : 'user',
    content: m.textContent.trim()
  }));
}

// Submit to backend + save to GitHub
compose.addEventListener('submit', async (ev) => {
  ev.preventDefault();
  const text = msgInput.value.trim();
  if (!text) return;
  addMsg('user', text);
  msgInput.value = '';

  try {
    await saveViaVercel({
      course: courseId,
      savedAt: new Date().toISOString(),
      video_chat: { atSeconds: lastTime, videoId, messages: collectTranscript() }
    });
  } catch (e) { console.error(e); }

  try {
    const response = await askLaptop({
      courseId,
      atSeconds: lastTime,
      messages: collectTranscript().map(m => ({
        role: m.role === 'assistant' ? 'assistant' : 'user',
        content: m.content
      }))
    });
    addMsg('ai', response.reply || 'No response.');
  } catch (err) {
    console.error(err);
    addMsg('ai', 'The assistant is unavailable right now. Please try again in a moment.');
  }
});

// Exit chat
exitBtn.addEventListener('click', () => {
  chat.hidden = true;
  overlay.classList.remove('show');
  try { player.playVideo(); } catch {}
});
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && !chat.hidden) {
    chat.hidden = true;
    overlay.classList.remove('show');
    try { player.playVideo(); } catch {}
  }
});
</script>

<script type="module" src="./assets/relevant-swap.js"></script>
<script type="module" src="./assets/relevant-swap.debug.js"></script>
</body>
</html>
